　1. C#中值类型和引用类型分别有哪些？　

　　　　值类型：结构体（数值类型，bool型，用户定义的结构体），枚举，可空类型。

　　　　引用类型：数组，用户定义的类、接口、委托，object，字符串。

2. 谈谈你对EF的理解

　　　　这个可以谈很多，比如说EF实现机制，最核心的是对象关系映射机制和LINQ To EF Provider，在此基础上的缓存机制、延迟加载、对象状态跟踪、事务等等，从对开发者的影响上来说，EF是微软官方的ORM框架，结束了之前各种第三方ORM混战的局面，统一了API，这无疑是开发者的福音。EF拥有非常优雅的，基于C#/VB语言优化的API，比如原生的LINQ查询，自然的Code First的对数据结构的定义，Fluent API方式的数据库和关系的定义等等。VS完美支持EF并且提供了多种数据库的适配。

　　3. 字段和属性有什么区别

　　　　如果你编写一些控件给别的开发者用，而需要给他们提供“数据绑定”这种傻瓜化的机制，那么使用属性才可以做到。
属性是方法而字段不是，当你用反射去掉用的时候，它们有各自的API。因为属性是方法，所以它可以和方法那样定义在接口中，或者被继承和重写，重写属性被ORM/AOP等框架用来注入代码。

4. 抽象方法和虚方法的区别

　　　　抽象方法一定是虚方法，虚方法未必是抽象方法。虚方法是指可以被继承类重写的方法，而抽象方法是指，基类是抽象类，没有实现它，因此必须被继承类重写的方法。

　5. new的几种用法

　　　　除了作为创建对象实例的关键字以外，new还有个罕见的用法，就是在派生类定义一个重名的同函数签名的方法，隐藏掉基类的方法。另外就是泛型约束定义构造函数约束的时候用。

　　6. 什么叫做泛型

　　　　从编程的角度说是在定义类或者方法的时候省去具体的类型，由调用者来指定，类型+泛型类型合成得到真正的类型。从实现机制上说，泛型是CLR在运行时动态根据泛型类型创建的匿名类型。从OO设计的角度说，泛型体现了多态性。泛型使得程序员可以复用数据结构和算法，并且适应不同的类型，享有编译期间的强类型检查和语法提示。
　　　　一些经典的FCL提供的泛型类型和接口： List<T>、Dictionary<T1, T2>这个属于复用数据结构　　 　IComparer<T>、IEnumerable<T>这个属于复用算法

7. 什么叫做类

　　　　就C#而言，类是对象的模板，对象是类的实例。C#是强类型语言，一切皆需要类型，除了内置的简单类型，那些其实例为引用对象的都叫做类。C#也允许定义抽象类和密封类，以及两者的叠加——静态类，它们都无法实例化，其实这是编译器的限制，本质上它们和一般的类没有区别，是特殊情况

8. 请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。
　　　　1.QueryString 传递一个或多个安全性要求不高或是结构简单的数值。但是对于传递数组或对象的话，就不能用这个方法了
　　　　2.session(viewstate) 简单，但易丢失 作用于用户个人,过量的存储会导致服务器内存资源的耗尽。
　　　　3.application 对象的作用范围是整个全局，也就是说对所有用户都有效。其常用的方法用Lock和UnLock
　　　　4.cookie 简单，但可能不支持，可能被伪造 Cookie是存放在客户端的，而session是存放在服务器端的。而且Cookie的使用要配合http://ASP.NET内置对象Request来使用
　　　　5.input ttype="hidden" 简单，可能被伪造
　　　　6.url参数简单，显示于地址栏，长度有限

　9. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?

　　　　接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。

10. 启动一个线程是用run()还是start()?

　　　　启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。

　11. GC是什么? 为什么要有GC?　

　　　　GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： System.gc() Runtime.getRuntime().gc()

　12. 什么是Web Service？

　　　　Web Service便是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。

13. c#中值类型和引用类型的区别

　　　　1.值类型的数据存储在内存的栈中；引用类型的数据存储在内存的堆中，而内存单元中只存放堆中对象的地址。

　　　　2.值类型存取速度快，引用类型存取速度慢。

　　　　3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针或引用

　　　　4.值类型继承自System.ValueType，引用类型继承自System.Object

　　　　5.栈的内存分配是自动释放；而堆在.NET中会有GC来释放

14. c#语言中，结构体和类的区别？　

　　　　1.结构是实值类型（Value Types），而类则是引用类型（Reference Types）。

　　　　2.结构使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation）。

　　　　3.所有结构成员默认都是Public，而类的变量和常量数则默认位Private，不过其他类成员默认都是Public。

　　　　4.结构成员不能被声明位Protected，而类成员可以。

15. BS与CS的联系与区别。

　　　　1.C/S是客户端需要安装专用的客户端软件，B/S是客户机上只要安装一个浏览器

　　　　2.C/S 一般建立在专用的网络上,C/S更强的适应范围,

　　　　3.C/S比B/S更安全。

　　　　4.C/S可以控制本机的其他程序、可以读写本地磁盘文件、可以与硬件交互。

　　　　5.B/S很难和本地硬件、程序、文件进行交互

16. post、get的区别　　

　　　　1.post的参数不会显示在浏览器地址栏中，get的参数会显示在浏览器地址栏中

　　　　2.用post可提交较大的数据量，get提交的数据量则非常小(2k)

　　　　3.用post可进行文件的提交，而用get则不可以

17. 常用的调用WebService的方法有哪些？　

　　　　1.使用WSDL.exe命令行工具。

　　　　2.使用http://VS.NET中的Add Web Reference菜单选项

　18. try{}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?

　　　　会执行，在return前执行。

19. 如何处理几十万条并发数据？

　　　　用存储过程或事务。取得最大标识的时候同时更新..注意主键不是自增量方式这种方法并发的时候是不会有重复主键的..取得最大标识要有一个存储过程来获取.

　20. 堆和栈的区别？

　　　　堆：一般由程序员分配释放。用new、malloc等分配内存函数分配得到的就是在堆上

　　　　栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。

21. StringBuilder 和 String 的区别？

　　　　1.StringBuilder 是可扩展的，在大量字符串拼接时使用

　　　　2.String 在进行运算时会产生一个新的实例

22. 请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。

　　　　1.session(viewstate) 简单，但易丢失application 全局

　　　　2.cookie 简单，但可能不支持，可能被伪造

　　　　3.input type="hidden" 简单，可能被伪造

　　　　4.url参数 简单，显示于地址栏，长度有限

　　　　5.数据库 稳定，安全，但性能相对弱

23. 向服务器发送请求有几种方式？

　　　　get,post。get一般为链接方式，post一般为按钮方式

　24. float f=-123.567F; int i=(int)f;i的值现在是_____?

　　　　-123。

25. 委托声明的关键字是______?

　　　　delegate

　　26. &和&&的区别。

　　　　&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）

27. MVC模式

　　　　MVC(Model-View-Controller)把交互系统的组成分解成模型、视图、控制器三种部件

　28. mvc的优点：

　　　　1.通过把项目分成model view和controller，使得复杂项目更加容易维护。

　　　　2.没有使用view state和服务器表单控件，可以更方便的控制应用程序的行为

　　　　3.应用程序通过controller来控制程序请求，可以提供丰富的url重写。

　　　　4.对单元测试的支持更加出色

　　　　5.在团队开发模式下表现更出众

29. MVC的不足：

　　　　（1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。
　　　　（2）视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。
　　　　（3）视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。
