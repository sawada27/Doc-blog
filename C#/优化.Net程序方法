1. 数据库访问性能优化
1）数据库的连接和关闭
（Using 及时回收）
　　访问数据库资源需要创建连接、打开连接和关闭连接几个操作。这些过程需要多次与数据库交换信息以通过身份验证，比较耗费服务器资源。 ASP.NET中提供了连接池（Connection Pool）改善打开和关闭数据库对性能的影响。系统将用户的数据库连接放在连接池中，需要时取出，关闭时收回连接，等待下一次的连接请求。

　　连接池的大小是有限的，如果在连接池达到最大限度后仍要求创建连接，必然大大影响性能。因此，在建立数据库连接后只有在真正需要操作时才打开连接，使用完毕后马上关闭，从而尽量减少数据库连接打开的时间，避免出现超出连接限制的情况。

2）使用存储过程
（预编译的Sql语句块，缺点是不易于维护，和迁移）
　　存储过程是存储在服务器上的一组预编译的SQL语句，类似于DOS系统中的批处理文件。存储过程具有对数据库立即访问的功能，信息处理极为迅 速。使用存储过程可以避免对命令的多次编译，在执行一次后其执行规划就驻留在高速缓存中，以后需要时只需直接调用缓存中的二进制代码即可。

　　另外，存储过程在服务器端运行，独立于ASP.NET程序，便于修改，最重要的是它可以减少数据库操作语句在网络中的传输。

3）优化查询语句

　　ASP.NET中ADO连接消耗的资源相当大，SQL语句运行的时间越长，占用系统资源的时间也越长。因此，尽量使用优化过的SQL语句以减少执行时间。比如，不在查询语句中包含子查询语句，充分利用索引等。
（关联表代替子查询 in 、not in）

4）使用索引

2. 程序内字符串操作性能优化

1）使用值类型的ToString方法。在连接字符串时，经常使用"+"号直接将数字添加到字符串中。这种方法虽然简单，也可以得到正确结果，但是由于涉及到不同的数据类型， 数字需要通过装箱操作转化为引用类型才可以添加到字符串中。但是装箱操作对性能影响较大，因为在进行这类处理时，将在托管堆中分配一个新的对象，原有的值 复制到新创建的对象中。

使用值类型的ToString方法可以避免装箱操作，从而提高应用程序性能。

2）运用StringBuilder类

　　String类对象是不可改变的，对于String对象的重新赋值在本质上是重新创建了一个String对象并将新值赋予该对象，其方法ToString对性能的提高并非很显著。

　　在处理字符串时，最好使用StringBuilder类，其.NET 命名空间是System.Text。该类并非创建新的对象，而是通过Append，Remove，Insert等方法直接对字符串进行操作，通过ToString方法返回操作结果。

其定义及操作语句如下所示：

int num;

System.Text.StringBuilder str = new System.Text.StringBuilder(); //创建字符串

str.Append(num.ToString()); //添加数值num

Response.Write(str.ToString); //显示操作结果

3)异步方式用IO
数据存储器和其他远程服务通常是最慢的部分
要 以异步方式调用所有数据访问 API 。


要 考虑缓存从数据库或远程服务检索的频繁访问的数据 (如果稍微过时的数据是可接受的话) 。根据具体的场景，可以使用 MemoryCache 或 DistributedCache。有关更多信息，请参阅 https://docs.microsoft.com/en-us/aspnet/core/performance/caching/response?view=aspnetcore-3.1.

要 尽量减少网络往返。能够单次调用完成就不应该多次调用来读取所需数据。
要 在 Entity Framework Core 访问数据以用作只读情况时， 使用 no-tracking 方式查询。EF Core 可以更高效地返回 no-tracking 查询的结果。
要 使用过滤器和聚集 LINQ 查询 (例如， .Where， .Select 或 .Sum 语句) ，以便数据库执行过滤提高性能 。
要 考虑 EF Core 可能在客户端解析一些查询运算符，这可能导致查询执行效率低下。有关更多信息，请参阅 客户端计算相关的性能问题。

不要 读取不需要的数据。编写查询时，仅返回当前 HTTP 请求所必需的数据。
不要 在集合上使用映射查询，这会导致执行 “N + 1” SQL 查询。有关更多信息，请参阅 优化子查询。

考虑优化应用程序请求处理管道中的 Middleware ，尤其是在管道中排在更前面运行的 Middleware 。这些组件对性能有很大影响。
考虑优化那些每个请求都要执行或每个请求多次执行的代码。例如，自定义日志，身份认证与授权或 transient 服务的创建等等。
建议 :

不要 使用自定义 middleware 运行长时任务 。
要 使用性能分析工具 ( 如 Visual Studio Diagnostic Tools 或 PerfView) 来定位 代码热点路径。

4)不要频繁创建HttpClient实例 用IHttpClientFactory去做

5)
3. 优化 Web 服务器计算机和特定应用程序的配置文件以符合您的特定需要

　　默认情况下，ASP.NET 配置被设置成启用最广泛的功能并尽量适应最常见的方案。因此，应用程序开发人员可以根据应用程序所使用的功能，优化和更改其中的某些配置，以提高应用程序的性能。下面的列表是您应该考虑的一些选项。


　　1)仅对需要的应用程序启用身份验证。默认情况下，身份验证模式为 Windows，或集成 NTLM。大多数情况下，对于需要身份验证的应用程序，最好在 Machine.config 文件中禁用身份验证，并在 Web.config 文件中启用身份验证。
　　2)根据适当的请求和响应编码设置来配置应用程序。ASP.NET 默认编码格式为 UTF-8。如果您的应用程序为严格的 ASCII，请配置应用程序使用 ASCII 以获得稍许的性能提高。


　　考虑对应用程序禁用 AutoEventWireup。在 Machine.config 文件中将 AutoEventWireup 属性设置为 false，意味着页面不将方法名与事件进行匹配和将两者挂钩（例如 Page_Load）。如果页面开发人员要使用这些事件，需要在基类中重写这些方法（例如，需要为页面加载事件重写 Page.OnLoad，而不是使用 Page_Load 方法）。如果禁用 AutoEventWireup，页面将通过将事件连接留给页面作者而不是自动执行它，获得稍许的性能提升。


　　从请求处理管线中移除不用的模块。默认情况下，服务器计算机的 Machine.config 文件中 <httpModules> 节点的所有功能均保留为激活。根据应用程序所使用的功能，您可以从请求管线中移除不用的模块以获得稍许的性能提升。检查每个模块及其功能，并按您的需要自 定义它。


　　例如，如果您在应用程序中不使用会话状态和输出缓存，则可以从 <httpModules> 列表中移除它们，以便请求在不执行其他有意义的处理时，不必执行每个模块的进入和离开代码。


4. 一定要禁用调试模式

　　在部署生产应用程序或进行任何性能测量之前，始终记住禁用调试模式。如果启用了调试模式，应用程序的性能可能受到非常大的影响。


5. 对于广泛依赖外部资源的应用程序，请考虑在多处理器计算机上启用网络园艺

　　ASP.NET 进程模型帮助启用多处理器计算机上的可缩放性，将工作分发给多个进程（每个 CPU 一个），并且每个进程都将处理器关系设置为其 CPU。此技术称为网络园艺。如果应用程序使用较慢的数据库服务器或调用具有外部依赖项的 COM 对象（这里只是提及两种可能性），则为您的应用程序启用网络园艺是有益的。但是，在决定启用网络园艺之前，您应该测试应用程序在网络园中的执行情况。


6. 只要可能，就缓存数据和页输出

　　ASP.NET 提供了一些简单的机制，它们会在不需要为每个页请求动态计算页输出或数据时缓存这些页输出或数据。另外，通过设计要进行缓存的页和数据请求（特别是在站点 中预期将有较大通讯量的区域），可以优化这些页的性能。与 .NET Framework 的任何 Web 窗体功能相比，适当地使用缓存可以更好的提高站点的性能，有时这种提高是超数量级的。

　　使用 ASP.NET 缓存机制有两点需要注意。首先，不要缓存太多项。缓存每个项均有开销，特别是在内存使用方面。不要缓存容易重新计算和很少使用的项。其次，给缓存的项分配 的有效期不要太短。很快到期的项会导致缓存中不必要的周转，并且经常导致更多的代码清除和垃圾回收工作。若关心此问题，请监视与 ASP.NET Applications 性能对象关联的 Cache Total Turnover Rate 性能计数器。高周转率可能说明存在问题，特别是当项在到期前被移除时。这也称作内存压力。

7. 选择适合页面或应用程序的数据查看机制

　　根据您选择在 Web 窗体页显示数据的方式，在便利和性能之间常常存在着重要的权衡。例如，DataGrid Web 服务器控件可能是一种显示数据的方便快捷的方法，但就性能而言它的开销常常是最大的。在某些简单的情况下，您通过生成适当的 HTML 自己呈现数据可能很有效，但是自定义和浏览器定向会很快抵销所获得的额外功效。Repeater Web 服务器控件是便利和性能的折衷。它高效、可自定义且可编程。

8. 将 SqlDataReader 类用于快速只进数据游标

　　SqlDataReader 类提供了一种读取从 SQL Server 数据库检索的只进数据流的方法。如果当创建 ASP.NET 应用程序时出现允许您使用它的情况，则 SqlDataReader 类提供比 DataSet 类更高的性能。情况之所以这样，是因为 SqlDataReader 使用 SQL Server 的本机网络数据传输格式从数据库连接直接读取数据。另外，SqlDataReader 类实现 IEnumerable 接口，该接口也允许您将数据绑定到服务器控件。有关更多信息，请参见 SqlDataReader 类。有关 ASP.NET 如何访问数据的信息，请参见通过 ASP.NET 访问数据。

9. 将 SQL Server 存储过程用于数据访问

　　在 .NET Framework 提供的所有数据访问方法中，基于 SQL Server 的数据访问是生成高性能、可缩放 Web 应用程序的推荐选择。使用托管 SQL Server 提供程序时，可通过使用编译的存储过程而不是特殊查询获得额外的性能提高。


10.   避免单线程单元 (STA) COM 组件

　　默认情况下，ASP.NET 不允许任何 STA COM 组件在页面内运行。若要运行它们，必须在 .aspx 文件内将 ASPCompat=true 属性包含在 @ Page 指令中。这样就将执行用的线程池切换到 STA 线程池，而且使 HttpContext 和其他内置对象可用于 COM 对象。前者也是一种性能优化，因为它避免了将多线程单元 (MTA) 封送到 STA 线程的任何调用。


　　使用 STA COM 组件可能大大损害性能，应尽量避免。若必须使用 STA COM 组件，如在任何 interop 方案中，则应在执行期间进行大量调用并在每次调用期间发送尽可能多的信息。另外，小心不要在构造页面期间创建任何 STA COM 组件。例如下面的代码中，在页面构造时将实例化由某个线程创建的 MySTAComponent，而该线程并不是将运行页面的 STA 线程。这可能对性能有不利影响，因为要构造页面就必须完成 MTA 和 STA 线程之间的封送处理。

<%@ Page Language="VB" ASPCompat="true" %>
< script runat=server>
Dim myComp as new MySTAComponent()
Public Sub Page_Load()
myComp.Name = "Bob"
End Sub
< /script>
< html>
< %
Response.Write(myComp.SayHello)
%>
< /html>

首选机制是推迟对象的创建，直到以后在 STA 线程下执行上述代码，如下面的例子所示。

<%@ Page Language="VB" ASPCompat="true" %>
< script runat=server>
Dim myComp
Public Sub Page_Load()
myComp = new MySTAComponent()
myComp.Name = "Bob"
End Sub
< /script>
< html>
< %
Response.Write(myComp.SayHello)
%>
< /html>

　　推荐的做法是在需要时或者在 Page_Load 方法中构造任何 COM 组件和外部资源。

　　永远不要将任何 STA COM 组件存储在可以由构造它的线程以外的其他线程访问的共享资源里。这类资源包括像缓存和会话状态这样的资源。即使 STA 线程调用 STA COM 组件，也只有构造此 STA COM 组件的线程能够实际为该调用服务，而这要求封送处理对创建者线程的调用。此封送处理可能产生重大的性能损失和可伸缩性问题。在这种情况下，请研究一下使 COM 组件成为 MTA COM 组件的可能性，或者更好的办法是迁移代码以使对象成为托管对象。

11.   将调用密集型的 COM 组件迁移到托管代码

　　.NET Framework 提供了一个简单的方法与传统的 COM 组件进行交互。其优点是可以在保留现有投资的同时利用新的平台。但是在某些情况下，保留旧组件的性能开销使得将组件迁移到托管代码是值得的。每一情况都是 不一样的，决定是否需要迁移组件的最好方法是对 Web 站点运行性能测量。建议您研究一下如何将需要大量调用以进行交互的任何 COM 组件迁移到托管代码。

　　许多情况下不可能将旧式组件迁移到托管代码，特别是在最初迁移 Web 应用程序时。在这种情况下，最大的性能障碍之一是将数据从非托管环境封送到托管环境。因此，在交互操作中，请在任何一端执行尽可能多的任务，然后进行一个 大调用而不是一系列小调用。例如，公共语言运行库中的所有字符串都是 Unicode 的，所以应在调用托管代码之前将组件中的所有字符串转换成 Unicode 格式。

　　另外，一处理完任何 COM 对象或本机资源就释放它们。这样，其他请求就能够使用它们，并且最大限度地减少了因稍后请求垃圾回收器释放它们所引起的性能问题。


12.   在 Visual Basic .NET 或 JScript 代码中使用早期绑定

　　以往，开发人员喜欢使用 Visual Basic、VBScript 和 JScript 的原因之一就是它们所谓“无类型”的性质。变量不需要显式类型声明，并能够简单地通过使用来创建它们。当从一个类型到另一个类型进行分配时，转换将自动执 行。不过，这种便利会大大损害应用程序的性能。

　　Visual Basic 现在通过使用 Option Strict 编译器指令来支持类型安全编程。为了向后兼容，默认情况下，ASP.NET 不启用该选项。但是，为了得到最佳性能，强烈建议在页中启用该选项。若要启用 Option Strict，请将 Strict 属性包括在 @ Page 指令中，或者，对于用户控件，请将该属性包括在 @ Control 指令中。下面的示例演示了如何设置该属性，并进行了四个变量调用以显示使用该属性是如何导致编译器错误的。

<%@ Page Language="VB" Strict="true" %>
< %
Dim B
Dim C As String
' This will cause a compiler error.
A = "Hello"
' This will cause a compiler error.
B = "World"
' This will not cause a compiler error.
C = "!!!!!!"
' But this will cause a compiler error.
C = 0
%>

　　JScript .NET 也支持无类型编程，但它不提供强制早期绑定的编译器指令。若发生下面任何一种情况，则变量是晚期绑定的：

　　被显式声明为 Object。

　　是无类型声明的类的字段。

　　是无显式类型声明的专用函数或方法成员，并且无法从其使用推断出类型。

　　最后一个差别比较复杂，因为如果 JScript .NET 编译器可以根据变量的使用情况推断出类型，它就会进行优化。在下面的示例中，变量 A 是早期绑定的，但变量 B 是晚期绑定的。

var A;

var B;

A = "Hello";


B = "World";


B = 0;

　　为了获得最佳的性能，当声明 JScript .NET 变量时，请为其分配一个类型。例如，var A : String。

13.   使请求管线内的所有模块尽可能高效

　　请求管线内的所有模块在每次请求中都有机会被运行。因此，当请求进入和离开模块时快速地触发代码至关重要，特别是在不使用模块功能的代码路径里。分别在使用及不使用模块和配置文件时执行吞吐量测试，对确定这些方法的执行速度非常有用。

14.   使用 HttpServerUtility.Transfer 方法在同一应用程序的页面间重定向

　　采用 Server.Transfer 语法，在页面中使用该方法可避免不必要的客户端重定向。

15.   必要时调整应用程序每个辅助进程的线程数

　　ASP.NET 的请求结构试图在执行请求的线程数和可用资源之间达到一种平衡。已知一个使用足够 CPU 功率的应用程序，该结构将根据可用于请求的 CPU 功率，来决定允许同时执行的请求数。这项技术称作线程门控。但是在某些条件下，线程门控算法不是很有效。通过使用与 ASP.NET Applications 性能对象关联的 Pipeline Instance Count 性能计数器，可以在 PerfMon 中监视线程门控。

　　当页面调用外部资源，如数据库访问或 XML Web services 请求时，页面请求通常停止并释放 CPU。如果某个请求正在等待被处理，并且线程池中有一个线程是自由的，那么这个正在等待的请求将开始被处理。遗憾的是，有时这可能导致 Web 服务器上存在大量同时处理的请求和许多正在等待的线程，而它们对服务器性能有不利影响。通常，如果门控因子是外部资源的响应时间，则让过多请求等待资源， 对 Web 服务器的吞吐量并无帮助。

　　为缓和这种情况，可以通过更改 Machine.config 配置文件 <processModel> 节点的 maxWorkerThreads 和 maxIOThreads 属性，手动设置进程中的线程数限制。

　　注意 辅助线程是用来处理 ASP.NET 请求的，而 IO 线程则是用于为来自文件、数据库或 XML Web services 的数据提供服务的。


　分配给这些属性的值是进程中每个 CPU 每类线程的最大数目。对于双处理器计算机，最大数是设置值的两倍。对于四处理器计算机，最大值是设置值的四倍。无论如何，对于有四个或八个 CPU 的计算机，最好更改默认值。对于有一个或两个处理器的计算机，默认值就可以，但对于有更多处理器的计算机的性能，进程中有一百或两百个线程则弊大于利。

　　注意 进程中有太多线程往往会降低服务器的速度，因为额外的上下文交换导致操作系统将 CPU 周期花在维护线程而不是处理请求上。

16.   适当地使用公共语言运行库的垃圾回收器和自动内存管理

　　小心不要给每个请求分配过多内存，因为这样垃圾回收器将必须更频繁地进行更多的工作。另外，不要让不必要的指针指向对象，因为它们将使对象保持 活动状态，并且应尽量避免含 Finalize 方法的对象，因为它们在后面会导致更多的工作。特别是在 Finalize 调用中永远不要释放资源，因为资源在被垃圾回收器回收之前可能一直消耗着内存。最后这个问题经常会对 Web 服务器环境的性能造成毁灭性的打击，因为在等待 Finalize 运行时，很容易耗尽某个特定的资源。

17.   如果有大型 Web 应用程序，可考虑执行预批编译

　　每当发生对目录的第一次请求时都会执行批编译。如果目录中的页面没有被分析并编译，此功能会成批分析并编译目录中的所有页面，以便更好地利用磁 盘和内存。如果这需要很长时间，则将快速分析并编译单个页面，以便请求能被处理。此功能带给 ASP.NET 性能上的好处，因为它将许多页面编译为单个程序集。从已加载的程序集访问一页比每页加载新的程序集要快。


　　批编译的缺点在于：如果服务器接收到许多对尚未编译的页面的请求，那么当 Web 服务器分析并编译它们时，性能可能较差。为解决这个问题，可以执行预批编译。为此，只需在应用程序激活之前向它请求一个页面，无论哪页均可。然后，当用户 首次访问您的站点时，页面及其程序集将已被编译。

　　没有简单的机制可以知道批编译何时发生。需一直等到 CPU 空闲或者没有更多的编译器进程（例如 csc.exe（C# 编译器）或 vbc.exe（Visual Basic 编译器））启动。

　　还应尽量避免更改应用程序的 /bin 目录中的程序集。更改页面会导致重新分析和编译该页，而替换 /bin 目录中的程序集则会导致完全重新批编译该目录。

　　在包含许多页面的大规模站点上，更好的办法可能是根据计划替换页面或程序集的频繁程度来设计不同的目录结构。不常更改的页面可以存储在同一目录中并在特定的时间进行预批编译。经常更改的页面应在它们自己的目录中（每个目录最多几百页）以便快速编译。

　　Web 应用程序可以包含许多子目录。批编译发生在目录级，而不是应用程序级。


18.   不要依赖代码中的异常

　　因为异常大大地降低性能，所以您不应该将它们用作控制正常程序流程的方式。如果有可能检测到代码中可能导致异常的状态，请执行这种操作。不要在 处理该状态之前捕获异常本身。常见的方案包括：检查 null，分配给将分析为数字值的 String 一个值，或在应用数学运算前检查特定值。下面的示例演示可能导致异常的代码以及测试是否存在某种状态的代码。两者产生相同的结果。

try

{

       result = 100 / num;

}

catch (Exception e)

{

       result = 0;

}

// ...to this.

if (num != 0)

       result = 100 / num;

else

       result = 0;

19.   使用 HttpResponse.Write 方法进行字符串串联

　　该方法提供非常有效的缓冲和连接服务。但是，如果您正在执行广泛的连接，请使用多个 Response.Write 调用。下面示例中显示的技术比用对 Response.Write 方法的单个调用连接字符串更快。

Response.Write("a");
Response.Write(myString);
Response.Write("b");
Response.Write(myObj.ToString());
Response.Write("c");
Response.Write(myString2);
Response.Write("d");

20.   除非有特殊的原因要关闭缓冲，否则使其保持打开

禁用 Web 窗体页的缓冲会导致大量的性能开销。

21.   只在必要时保存服务器控件视图状态

　　自动视图状态管理是服务器控件的功能，该功能使服务器控件可以在往返过程上重新填充它们的属性值（您不需要编写任何代码）。但是，因为服务器控 件的视图状态在隐藏的窗体字段中往返于服务器，所以该功能确实会对性能产生影响。您应该知道在哪些情况下视图状态会有所帮助，在哪些情况下它影响页的性 能。例如，如果您将服务器控件绑定到每个往返过程上的数据，则将用从数据绑定操作获得的新值替换保存的视图状态。在这种情况下，禁用视图状态可以节省处理 时间。

　　默认情况下，为所有服务器控件启用视图状态。若要禁用视图状态，请将控件的EnableViewState 属性设置为 false，如下面的 DataGrid 服务器控件示例所示。

<asp:datagrid EnableViewState="false" datasource="..." runat="server"/>

　　您还可以使用 @ Page 指令禁用整个页的视图状态。当您不从页回发到服务器时，这将十分有用：

<%@ Page EnableViewState="false" %>

　　注意 @ Control 指令中也支持 EnableViewState 属性，该指令允许您控制是否为用户控件启用视图状态。

　　若要分析页上服务器控件使用的视图状态的数量，请（通过将 trace="true" 属性包括在 @ Page 指令中）启用该页的跟踪并查看 Control Hierarchy 表的 Viewstate 列。有关跟踪和如何启用它的信息，请参见 ASP.NET 跟踪。

22.   避免到服务器的不必要的往返过程

　　虽然您很可能希望尽量多地使用 Web 窗体页框架的那些节省时间和代码的功能，但在某些情况下却不宜使用 ASP.NET 服务器控件和回发事件处理。

　　通常，只有在检索或存储数据时，您才需要启动到服务器的往返过程。多数数据操作可在这些往返过程间的客户端上进行。例如，从 HTML 窗体验证用户输入经常可在数据提交到服务器之前在客户端进行。通常，如果不需要将信息传递到服务器以将其存储在数据库中，那么您不应该编写导致往返过程的 代码。

　　如果您开发自定义服务器控件，请考虑让它们为支持 ECMAScript 的浏览器呈现客户端代码。通过以这种方式使用服务器控件，您可以显著地减少信息被不必要的发送到 Web 服务器的次数。

　　使用 Page.IsPostBack 避免对往返过程执行不必要的处理

　　如果您编写处理服务器控件回发处理的代码，有时可能需要在首次请求页时执行其他代码，而不是当用户发送包含在该页中的 HTML 窗体时执行的代码。根据该页是否是响应服务器控件事件生成的，使用 Page.IsPostBack 属性有条件地执行代码。例如，下面的代码演示如何创建数据库连接和命令，该命令在首次请求该页时将数据绑定到 DataGrid 服务器控件。

void Page_Load(Object sender, EventArgs e)

{

       // Set up a connection and command here.

       if (!Page.IsPostBack)

       {

              String query = "select * from Authors where FirstName like '%JUSTIN%'";

              myCommand.Fill(ds, "Authors");

              myDataGrid.DataBind();

       }

}

　　由于每次请求时都执行 Page_Load 事件，上述代码检查 IsPostBack 属性是否设置为 false。如果是，则执行代码。如果该属性设置为 true，则不执行代码。

　　注意 如果不运行这种检查，回发页的行为将不更改。Page_Load 事件的代码在执行服务器控件事件之前执行，但只有服务器控件事件的结果才可能在输出页上呈现。如果不运行该检查，仍将为 Page_Load 事件和该页上的任何服务器控件事件执行处理。

23.   当不使用会话状态时禁用它

　　并不是所有的应用程序或页都需要针对于具体用户的会话状态，您应该对任何不需要会话状态的应用程序或页禁用会话状态。

　　若要禁用页的会话状态，请将 @ Page 指令中的 EnableSessionState 属性设置为 false。例如，<%@ Page EnableSessionState="false" %>。

　　注意 如果页需要访问会话变量，但不打算创建或修改它们，则将 @ Page 指令中的 EnableSessionState 属性设置为 ReadOnly。

　　还可以禁用 XML Web services 方法的会话状态。有关更多信息，请参见使用 ASP.NET 和 XML Web services 客户端创建的 XML Web services。

　　若要禁用应用程序的会话状态，请在应用程序 Web.config 文件的 sessionstate 配置节中将 mode 属性设置为 off。例如，<sessionstate mode="off" />。

24.   仔细选择会话状态提供程序

　　ASP.NET 为存储应用程序的会话数据提供了三种不同的方法：进程内会话状态、作为 Windows 服务的进程外会话状态和 SQL Server 数据库中的进程外会话状态。每种方法都有自己的优点，但进程内会话状态是迄今为止速度最快的解决方案。如果只在会话状态中存储少量易失数据，则建议您使用 进程内提供程序。进程外解决方案主要用于跨多个处理器或多个计算机缩放应用程序，或者用于服务器或进程重新启动时不能丢失数据的情况。有关更多信息，请参 见 ASP.NET 状态管理。

25.   不使用不必要的Server Control

　　ASP.net中，大量的服务器端控件方便了程序开发，但也可能带来性能的损失，因为用户每操作一次服务器端控件，就产生一次与服务器端的往返过程。因此，非必要，应当少使用Server Control。

26.   ASP.NET应用程序性能测试

　　在对ASP.NET应用程序进行性能测试之前，应确保应用程序没有错误，而且功能正确。具体的性能测试可以采用以下工具进行：Web Application Strees Tool (WAS)是Microsoft发布的一个免费测试工具，可以从http://webtool.rte.microsoft.com/上下载。它可以模拟成百上千个用户同时对web应用程序进行访问请求，在服务器上形成流量负载，从而达到测试的目的，可以生成平均TTFB、平均TTLB等性能汇总报告。

　　Application Center Test (ACT) 是一个测试工具，附带于Visual Studio.NET的企业版中，是Microsoft正式支持的web应用程序测试工具。它能够直观地生成图表结果，功能比WAS多，但不具备多个客户 机同时测试的能力。

　　现在写一个asp.net的web应用程序变得非常的简单,许多的程序员都不愿花时间去构建一个性能良好的应用程序。本文将要讨论提高web应 用程序性能的十大方法。我将不限于只讨论asp.net应用程序的内容，因为它们只是web应用程序的一个子集。本文也不能提供一个完整提高web应用程 序性能的指南，因为这需要一本书的篇幅。本文只提供一个提高web应用程序性能的良好的开端。（剩下的只有我们自己慢慢研究了）。

　　在工作这外，我经常去攀岩，在每次攀岩之前，我都会重温一下攀岩线路图及看一下前面的成功的攀岩者的建议。因为我们需要它们的成功经验。同样的，当你需要修改某个有性能问题的程序或者是要开发一个高性能的站点时，你也需要学习怎么样写一个高性能的web应用程序。

　　我个人的经验主要来源于在微软的ASP.NET组担任程序经理，运行和管理www.asp.net网站，和协助开发Community Server（它是ASP.NET Forums，.Text, 和 nGallery的集成升级版本软件）。我想这些经验能我让来帮助大家。

　　你也许会想到把你的应用程序划分成不同的逻辑层。你也可能听过三层物理架构或N层架构，这是最常用的架构模式，它把不同的程序功能物理的分配给 各个硬件来执行。这样，如果我们想提高应用程序的性能的话，加一些硬件就可以达到目的了。按理说这种方法能提高应用程序的性能,但是我们应该避免使用这种 方法。所以，只要有可能，我们都应该把ASP.NET页面和它用到的组件放到一个应用程序中运行。

　　因为分布式的布署，要用到Web Services或者Remoting，它将使应用程序的性能下降20%或者更多。

　　对于数据层有点不同，最好还是把它独立出来布署，用一个单独的硬件来运行它。虽然这样，但是数据库仍然是应用程序性能的瓶颈。因此，当你想优化你的程序的时候，首先想到的地方就应该是优化数据层了。

　　在修改应用程序的出现性能问题的地方之前，你要先确认出问题的地方的程序看起来很严密，性能分析器对于查找应用程序哪些地方花费了多长时间非常有用。这些地方是我们用直觉感觉不到的。

　　本文讨论两种类型的性能优化：一种是大的性能优化(big optimizations)，如用ASP.NET的Cache；另一种是小的性能优化（tiny optimizations）。小幅的性能优化有时候非常有用。你只对你的代码作一个小的改到，然后一次调用它一千或一万次。作一次大的性能优化，你会发 生你的应用程序的速度会有一个很大的提升。作一次小的性能优化，也许每次请求只能提高一微秒，但是如果每天的请求量很大的话，那么应用程序就有很显著的性能提升。

　　数据层的性能

　　当你要优化一个应用程序的性能的时候，你可以按下面的顺序工作：你的代码要访问数据库？如果要，访问数据库频率怎么样？同样，这种测试方法也可 以用在用Web Service或.NET Remoting的程序代码中。本文将不讨论用Web Services和Remoting的程序优化的问题。

　　如果在你的代码中有一段必须访问数据库的请求，而你在其它的地方又看到实现同样的功能 的代码，那么你首先要优化它。修改和完善继续测试，除非你有一个非常大的性能问题，你的时间最好花在优化查询，连接数据库，返回数据集的大小，以及一次查询往返回的时间上。

　　根据经验的总结，让我们来看看十个能帮助你提升你的应用程序性能的经验，我将按将它们提升效率的多少从大到小小依次说明。

　　一、返回多个数据集

　　检查你的访问数据库的代码，看是否存在着要返回多次的请求。每次往返降低了你的应用程序的每秒能够响应请求的次数。通过在单个数据库请求中返回多个结果集，可以减少与数据库通信的时间，使你的系统具有扩展性，也可以减少数据库服务器响应请求的工作量。

　　如果你是用动态的SQL语句来返回多个数据集，那我建议你用存储过程来替代动态的SQL语句。是否把业务逻辑写到存储过程中，这个有点争议。但 是我认为，把业务逻辑写到存储过程里面可以限制返回结果集的大小，减小网络数据的流量，在逻辑层也不用在过滤数据，这是一个好事情。

　　用SqlCommand对象的ExecuteReader方法返回一个强类型的业务对象，再调用NextResult方法来移动数据集指针来定 位数据集。示例一演示了一个返回多个ArrayList强类型对象的例子。只从数据库中返回你需要的数据可以大大的减小你的服务器所耗用的内存。

　　二、对数据进行分页

　　ASP.NET的DataGrid有一个非常有用的功能：分页。如果DataGrid允许分页，在某一时刻它只下载某一页的数据，另外，它有一个数据分页的浏览导航栏，它让你可以选择浏览某一页，而且每次只下载一页的数据。

　　但是它有一个小小的缺点，就是你必须把所有的数据都绑定到DataGrid中。也就是说，你的数据层必须返回所有的数据，然后DataGrid 再根据当前页过滤出当前页所需要的数据显示出来。如果有一个一万条记录的结果集要用DataGrid进行分页，假设DataGrid每页只显示25条数 据，那就意味着每次请求都有9975条数据都是要丢弃的。每次请求都要返回这么大的数据集，对应用程序的性能影响是非常大的。

　　一个好的解决方案是写一个分页的存储过程，例子2是一个用于对Northwind数据库orders表的分页存储过程。你只需要传当前页码，每页显示的条数两个参数进来，存储过程会返回相应的结果。

　　在服务器端，我专门写了一个分页的控件来处理数据的分页，在这里，我用了第一个方法，在一个存储过程里面返回了两个结果集：数据记录总数和要求的结果集。

　　返回的记录总数取决于要执行查询，例如，一个where条件可以限制返回的结果集的大小。因为在分页界面中必须要根据数据集记录的大小来计算总 的页数，所以必须要返回结果集的记录数。例如，如果一共有1000000条记录，如果用where条件就可以过滤成只返回1000条记录，存储过程的分页 逻辑应该知道返回那些需要显示的数据。

　　三、连接池

　　用TCP来连接你的应用程序与数据库是一件昂贵的事情（很费时的事情），微软的开发者可以通过用连接池来反复的使用数据库的连接。比起每次请求 都用TCP来连一次数据库，连接池只有在不存在有效的连接时才新建一个TCP连接。当关闭一个连接的时候，它会被放到池中，它仍然会保持与数据库的连接， 这样就可以减少与数据库的TCP连接次数。

　　当然，你要注意那些忘记关的连接，你应在每次用完连接后马上关闭它。我要强调的是：无论什么人说.NET Framework中的GC(垃圾收集器)总会在你用完连接对象后调用连接对象的Close或者Dispose方法显式的关闭你的连接。不要期望CLR会 在你想象的时间内关掉连接，虽然CLR最终都要销毁对象和关闭边接，但是我们并不能确定它到底会在什么时候做这些事情。

　　要用连接池优化，有两条规则，第一，打开连接，处理数据，然后关闭连接。如果你必须在每次请求中多次打开或关闭连接，这好过一直打开一个边接， 然后把它传到各个方法中。第二，用相同的连接字符串（或者用相同的用户标识，当你用集成认证的时候）。如果你没有用相同的连接字符串，如你用基于登录用户 的连接字符串，这将不能利用连接池的优化功能。如果你用的是集成的论证，因为用户很多，所以你也不能充分利用连接池的优化功能。.NET CLR提供了一个数据性能计数器，它在我们需要跟踪程序性能特性的时候非常有用，当然也包括连接池的跟踪了。

　　无论你的应用程序什么时候要连在另一台机子的资源，如数据库，你都应该重点优化你连资源所花的时间，接收和发送数据的时间，以及往返回之间的次数。优化你的应用程序中的每一个处理点（process hop），它是提高你的应用的性能的出发点。

　　应用程序层包含与数据层连接，传送数据到相应的类的实例以及业务处理的逻辑。例如，在Community Server中，要组装一个Forums或者Threads集合，然后应用业务逻辑，如授权，更重要的，这里要完成缓存逻辑。

　　四、 ASP.NET缓存API

　　在写应用程序之前,你要做的第一件事是让应用程序最大化的利用ASP.NET的缓存功能。

　　如果你的组件是要在Asp.net应用程序中运行，你只要把System.Web.dll引用到你的项目中就可以了。然后用HttpRuntime.Cache属性就可访问Cache了（也可以通过Page.Cache或HttpContext.Cache访问）。

　　有以下几条缓存数据的规则。第一，数据可能会被频繁的被使用，这种数据可以缓存。第二，数据的访问频率非常高，或者一个数据的访问频率不高，但 是它的生存周期很长，这样的数据最好也缓存起来。第三是一个常常被忽略的问题，有时候我们缓存了太多数据，通常在一台X86的机子上，如果你要缓存的数据 超过800M的话，就会出现内存溢出的错误。所以说缓存是有限的。换名话说，你应该估计缓存集的大小，把缓存集的大小限制在10以内，否则它可能会出问 题。在Asp.net中，如果缓存过大的话也会报内存溢出错误，特别是如果缓存大的DataSet对象的时候。

　　这里有几个你必须了解的重要的缓存机制。首先是缓存实现了“最近使用”原则（ a least-recently-used algorithm），当缓存少的时候，它会自动的强制清除那些无用的缓存。其次 “条件依赖”强制清除原则（expiration dependencies），条件可以是时间，关键字和文件。以时间作为条件是最常用的。在asp.net2.0中增加一更强的条件，就是数据库条件。当 数据库中的数据发生变化时，就会强制清除缓存。要更深入的了解数据库条件依赖请看Dino Esposito 在MSDN杂志2004年七月刊的Cutting Edge专栏文章。

　　五、 预请求缓存

　　在前面，我提到过即使我们只对某些地方作了一个小小的性能改进也可以获得大的性能提升，我非常喜欢用预请求缓存来提升程序的性能。

　　虽然Cache API设计成用来保存某段时间的数据，而预请求缓存只是保存某个时期的某个请求的内容。如果某个请求的访问频率高，而且这个请求只需要提取，应用，修改或者更新数据一次。那么就可以预缓存该请求。我们举个例子来说明。

　　在CS的论坛应用程序中，每一个页面的服务器控件都要求得到用于决定它的皮肤（skin）的自定义的数据，以决定用哪个样式表及其它的一些个性 化的东西。这里面的某些数据可能要长时间的保存，有些时间则不然，如控件的skin数据，它只需要应用一次，而后就可以一直使用。

　　要实现预请求缓存，用Asp.net 的HttpContext类，HttpContext类的实例在每一个请求中创建，在请求期间的任何地方都可以通过 HttpContext.Current属性访问。HttpContext类有一个Items集合属性，在请求期间所有的对象和数据都被添加到这个集合中 缓存起来。和你用Cache缓存访问频率高数据一样，你可以用HttpContext.Items缓存那些每个请求都要用到的基础数据。它背后的逻辑很简 单：我们向HttpContext.Items中添加一个数据，然后再从它里面读出数据。

　　六、 后台处理

　　通过上面的方法你的应用程序应该运行得很快了，是不是？但是在某些时候，程序中的一次请求中可能要执行一个非常耗时的任务。如发送邮件或者是检查提交的数据的正确性等。

　　当我们把asp.net Forums 1.0集成在CS中的时侯，发现提交一个新的帖子的时候会非常的慢。每次新增一个帖子的时侯，应用程序首先要检查这个帖子是不是重复提的，然后用 “badword”过滤器来过滤，检查图片附加码，作帖子的索引，把它添加到合适的队列中，验证它的附件，最后，发邮件到它的订阅者邮件箱中。显然，这个 工作量很大。

　　结果是它把大量的时间都花在做索引和发送邮件中了。做帖子的索引是一项很耗时的操作，而发邮件给订阅都需要连接到SMTP服务，然后给每一个订阅者都发一封邮件，随着订阅用户的增加，发送邮件的时间会更长。

　　索引和发邮件并不需要在每次请求时触发，理想状态下，我们想要批量的处理这些操作，每次只发25封邮件或者每隔5分钟把所有的要发的新邮件发一次。我们决定使用与数据库原型缓存一样的代码，但是失败了，所以又不得不回到VS.NET 2005。

　　我们在System.Threading命名空间下找到了Timer类，这个类非常有用，但却很少有人知道，Web开发人员则更少有人知道了。 一旦他建了该类的实例，每隔一个指定的时间，Timer类就会从线程池中的一个线程中调用指定的回调函数。这意味着你的asp.net应用程序可以在没有 请求的时候也可以运行。这就是后以处理的解决方案。你就可以让做索引和发邮件工作在后台运行，而不是在每次请求的时候必须执行。

　　后台运行的技术有两个问题，第一是，当你的应用程序域卸载后，Timer类实例就会停止运行了。也就是不会调用回调方法了。另外，因为CLR的 每个进程中都有许多的线程在运行，你将很难让Timer获得一个线程来执行它，或者能执行它，但会延时。Asp.net层要尽量少的使用这种技术，以减少 进程中线程的数量，或者只让请求用一小部分的线程。当然如果你有大量的异步工作的话，那就只能用它了。

　　这里没有足够的空间有贴代码，你可以从http://www.rob-howard.net/中下载示例程序，请下载Blackbelt TechEd 2004的示例程序。

　　七、 页面输出缓存和代理服务
  
　　Asp.net是你的界面层（或者说应该是），它包含页面，用户控件，服务器控件（HttpHandlers 和HttpModules）以及它们生成的内容。如果你有一个Asp.net页面用来输出html，xml,imgae或者是其它的数据，对每一个请求你 都用代码来生成相同的输出内容，你就很有必要考虑用页面输出缓存了。

　　你只要简单的把下面的这一行代码复制到你的页面中就可以实现了：

　　你就可以有效的利用第一次请求里生成的页面输出缓存内容，60秒后重新生成一道页面内容。这种技术其实也是运用一些低层的Cache API来实现。用页面输出缓存有几个参数可以配置，如上面所说的VaryByParams参数，该参数表示什么时候触发重输出的条件，也可以指定在 Http Get或Http Post 请求模式下缓存输出。例如当我们设置该参数为VaryByParams=”Report”的时候，default.aspx?Report=1或者 default.aspx?Report=2请求的输出都会被缓存起来。参数的值可以是多个用分号隔开参数。

　　许多人都没有意识到当用页面输出缓存的时候，asp.net也会生成HTTP头集（HTTP Header）保存在下游的缓存服务器中，这些信息可以用于Microsoft Internet安全性中以及加速服务器的响应速度。当HTTP缓存的头被重置时，请求的内容会被缓在网络资源中，当客户端再次请求该内容时，就不会再从 源服务器上获得内容了，而直接从缓存中获得内容。

　　虽然用页面输出缓存不提高你的应用程序性能，但是它能减少了从的服务器中加载已缓存页面内容的次数。当然，这仅限于缓存匿名用户可以访问的页面。因为一旦页面被缓存后，就不能再执行授权操作了。
